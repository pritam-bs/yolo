// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'camera_inference_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$CameraInferenceEvent {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CameraInferenceEvent);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CameraInferenceEvent()';
}


}

/// @nodoc
class $CameraInferenceEventCopyWith<$Res>  {
$CameraInferenceEventCopyWith(CameraInferenceEvent _, $Res Function(CameraInferenceEvent) __);
}


/// Adds pattern-matching-related methods to [CameraInferenceEvent].
extension CameraInferenceEventPatterns on CameraInferenceEvent {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( InitializeCamera value)?  initializeCamera,TResult Function( ChangeModel value)?  changeModel,TResult Function( FlipCamera value)?  flipCamera,TResult Function( SetZoomLevel value)?  setZoomLevel,TResult Function( UpdateConfidenceThreshold value)?  updateConfidenceThreshold,TResult Function( UpdateIouThreshold value)?  updateIouThreshold,TResult Function( UpdateNumItemsThreshold value)?  updateNumItemsThreshold,TResult Function( DetectionsOccurred value)?  detectionsOccurred,TResult Function( ToggleSlider value)?  toggleSlider,TResult Function( UpdateFps value)?  updateFps,TResult Function( UpdateLensFacing value)?  updateLensFacing,TResult Function( RetryModelDownload value)?  retryModelDownload,TResult Function( ResumeCamera value)?  resumeCamera,TResult Function( SetInitialConfig value)?  setInitialConfig,TResult Function( StartSystemMonitor value)?  startSystemMonitor,required TResult orElse(),}){
final _that = this;
switch (_that) {
case InitializeCamera() when initializeCamera != null:
return initializeCamera(_that);case ChangeModel() when changeModel != null:
return changeModel(_that);case FlipCamera() when flipCamera != null:
return flipCamera(_that);case SetZoomLevel() when setZoomLevel != null:
return setZoomLevel(_that);case UpdateConfidenceThreshold() when updateConfidenceThreshold != null:
return updateConfidenceThreshold(_that);case UpdateIouThreshold() when updateIouThreshold != null:
return updateIouThreshold(_that);case UpdateNumItemsThreshold() when updateNumItemsThreshold != null:
return updateNumItemsThreshold(_that);case DetectionsOccurred() when detectionsOccurred != null:
return detectionsOccurred(_that);case ToggleSlider() when toggleSlider != null:
return toggleSlider(_that);case UpdateFps() when updateFps != null:
return updateFps(_that);case UpdateLensFacing() when updateLensFacing != null:
return updateLensFacing(_that);case RetryModelDownload() when retryModelDownload != null:
return retryModelDownload(_that);case ResumeCamera() when resumeCamera != null:
return resumeCamera(_that);case SetInitialConfig() when setInitialConfig != null:
return setInitialConfig(_that);case StartSystemMonitor() when startSystemMonitor != null:
return startSystemMonitor(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( InitializeCamera value)  initializeCamera,required TResult Function( ChangeModel value)  changeModel,required TResult Function( FlipCamera value)  flipCamera,required TResult Function( SetZoomLevel value)  setZoomLevel,required TResult Function( UpdateConfidenceThreshold value)  updateConfidenceThreshold,required TResult Function( UpdateIouThreshold value)  updateIouThreshold,required TResult Function( UpdateNumItemsThreshold value)  updateNumItemsThreshold,required TResult Function( DetectionsOccurred value)  detectionsOccurred,required TResult Function( ToggleSlider value)  toggleSlider,required TResult Function( UpdateFps value)  updateFps,required TResult Function( UpdateLensFacing value)  updateLensFacing,required TResult Function( RetryModelDownload value)  retryModelDownload,required TResult Function( ResumeCamera value)  resumeCamera,required TResult Function( SetInitialConfig value)  setInitialConfig,required TResult Function( StartSystemMonitor value)  startSystemMonitor,}){
final _that = this;
switch (_that) {
case InitializeCamera():
return initializeCamera(_that);case ChangeModel():
return changeModel(_that);case FlipCamera():
return flipCamera(_that);case SetZoomLevel():
return setZoomLevel(_that);case UpdateConfidenceThreshold():
return updateConfidenceThreshold(_that);case UpdateIouThreshold():
return updateIouThreshold(_that);case UpdateNumItemsThreshold():
return updateNumItemsThreshold(_that);case DetectionsOccurred():
return detectionsOccurred(_that);case ToggleSlider():
return toggleSlider(_that);case UpdateFps():
return updateFps(_that);case UpdateLensFacing():
return updateLensFacing(_that);case RetryModelDownload():
return retryModelDownload(_that);case ResumeCamera():
return resumeCamera(_that);case SetInitialConfig():
return setInitialConfig(_that);case StartSystemMonitor():
return startSystemMonitor(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( InitializeCamera value)?  initializeCamera,TResult? Function( ChangeModel value)?  changeModel,TResult? Function( FlipCamera value)?  flipCamera,TResult? Function( SetZoomLevel value)?  setZoomLevel,TResult? Function( UpdateConfidenceThreshold value)?  updateConfidenceThreshold,TResult? Function( UpdateIouThreshold value)?  updateIouThreshold,TResult? Function( UpdateNumItemsThreshold value)?  updateNumItemsThreshold,TResult? Function( DetectionsOccurred value)?  detectionsOccurred,TResult? Function( ToggleSlider value)?  toggleSlider,TResult? Function( UpdateFps value)?  updateFps,TResult? Function( UpdateLensFacing value)?  updateLensFacing,TResult? Function( RetryModelDownload value)?  retryModelDownload,TResult? Function( ResumeCamera value)?  resumeCamera,TResult? Function( SetInitialConfig value)?  setInitialConfig,TResult? Function( StartSystemMonitor value)?  startSystemMonitor,}){
final _that = this;
switch (_that) {
case InitializeCamera() when initializeCamera != null:
return initializeCamera(_that);case ChangeModel() when changeModel != null:
return changeModel(_that);case FlipCamera() when flipCamera != null:
return flipCamera(_that);case SetZoomLevel() when setZoomLevel != null:
return setZoomLevel(_that);case UpdateConfidenceThreshold() when updateConfidenceThreshold != null:
return updateConfidenceThreshold(_that);case UpdateIouThreshold() when updateIouThreshold != null:
return updateIouThreshold(_that);case UpdateNumItemsThreshold() when updateNumItemsThreshold != null:
return updateNumItemsThreshold(_that);case DetectionsOccurred() when detectionsOccurred != null:
return detectionsOccurred(_that);case ToggleSlider() when toggleSlider != null:
return toggleSlider(_that);case UpdateFps() when updateFps != null:
return updateFps(_that);case UpdateLensFacing() when updateLensFacing != null:
return updateLensFacing(_that);case RetryModelDownload() when retryModelDownload != null:
return retryModelDownload(_that);case ResumeCamera() when resumeCamera != null:
return resumeCamera(_that);case SetInitialConfig() when setInitialConfig != null:
return setInitialConfig(_that);case StartSystemMonitor() when startSystemMonitor != null:
return startSystemMonitor(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initializeCamera,TResult Function( ModelType model)?  changeModel,TResult Function()?  flipCamera,TResult Function( double zoomLevel)?  setZoomLevel,TResult Function( double threshold)?  updateConfidenceThreshold,TResult Function( double threshold)?  updateIouThreshold,TResult Function( int threshold)?  updateNumItemsThreshold,TResult Function( List<DetectionResult> detections)?  detectionsOccurred,TResult Function( SliderType type)?  toggleSlider,TResult Function( double fps)?  updateFps,TResult Function( LensFacing lensFacing)?  updateLensFacing,TResult Function()?  retryModelDownload,TResult Function()?  resumeCamera,TResult Function()?  setInitialConfig,TResult Function()?  startSystemMonitor,required TResult orElse(),}) {final _that = this;
switch (_that) {
case InitializeCamera() when initializeCamera != null:
return initializeCamera();case ChangeModel() when changeModel != null:
return changeModel(_that.model);case FlipCamera() when flipCamera != null:
return flipCamera();case SetZoomLevel() when setZoomLevel != null:
return setZoomLevel(_that.zoomLevel);case UpdateConfidenceThreshold() when updateConfidenceThreshold != null:
return updateConfidenceThreshold(_that.threshold);case UpdateIouThreshold() when updateIouThreshold != null:
return updateIouThreshold(_that.threshold);case UpdateNumItemsThreshold() when updateNumItemsThreshold != null:
return updateNumItemsThreshold(_that.threshold);case DetectionsOccurred() when detectionsOccurred != null:
return detectionsOccurred(_that.detections);case ToggleSlider() when toggleSlider != null:
return toggleSlider(_that.type);case UpdateFps() when updateFps != null:
return updateFps(_that.fps);case UpdateLensFacing() when updateLensFacing != null:
return updateLensFacing(_that.lensFacing);case RetryModelDownload() when retryModelDownload != null:
return retryModelDownload();case ResumeCamera() when resumeCamera != null:
return resumeCamera();case SetInitialConfig() when setInitialConfig != null:
return setInitialConfig();case StartSystemMonitor() when startSystemMonitor != null:
return startSystemMonitor();case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initializeCamera,required TResult Function( ModelType model)  changeModel,required TResult Function()  flipCamera,required TResult Function( double zoomLevel)  setZoomLevel,required TResult Function( double threshold)  updateConfidenceThreshold,required TResult Function( double threshold)  updateIouThreshold,required TResult Function( int threshold)  updateNumItemsThreshold,required TResult Function( List<DetectionResult> detections)  detectionsOccurred,required TResult Function( SliderType type)  toggleSlider,required TResult Function( double fps)  updateFps,required TResult Function( LensFacing lensFacing)  updateLensFacing,required TResult Function()  retryModelDownload,required TResult Function()  resumeCamera,required TResult Function()  setInitialConfig,required TResult Function()  startSystemMonitor,}) {final _that = this;
switch (_that) {
case InitializeCamera():
return initializeCamera();case ChangeModel():
return changeModel(_that.model);case FlipCamera():
return flipCamera();case SetZoomLevel():
return setZoomLevel(_that.zoomLevel);case UpdateConfidenceThreshold():
return updateConfidenceThreshold(_that.threshold);case UpdateIouThreshold():
return updateIouThreshold(_that.threshold);case UpdateNumItemsThreshold():
return updateNumItemsThreshold(_that.threshold);case DetectionsOccurred():
return detectionsOccurred(_that.detections);case ToggleSlider():
return toggleSlider(_that.type);case UpdateFps():
return updateFps(_that.fps);case UpdateLensFacing():
return updateLensFacing(_that.lensFacing);case RetryModelDownload():
return retryModelDownload();case ResumeCamera():
return resumeCamera();case SetInitialConfig():
return setInitialConfig();case StartSystemMonitor():
return startSystemMonitor();case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initializeCamera,TResult? Function( ModelType model)?  changeModel,TResult? Function()?  flipCamera,TResult? Function( double zoomLevel)?  setZoomLevel,TResult? Function( double threshold)?  updateConfidenceThreshold,TResult? Function( double threshold)?  updateIouThreshold,TResult? Function( int threshold)?  updateNumItemsThreshold,TResult? Function( List<DetectionResult> detections)?  detectionsOccurred,TResult? Function( SliderType type)?  toggleSlider,TResult? Function( double fps)?  updateFps,TResult? Function( LensFacing lensFacing)?  updateLensFacing,TResult? Function()?  retryModelDownload,TResult? Function()?  resumeCamera,TResult? Function()?  setInitialConfig,TResult? Function()?  startSystemMonitor,}) {final _that = this;
switch (_that) {
case InitializeCamera() when initializeCamera != null:
return initializeCamera();case ChangeModel() when changeModel != null:
return changeModel(_that.model);case FlipCamera() when flipCamera != null:
return flipCamera();case SetZoomLevel() when setZoomLevel != null:
return setZoomLevel(_that.zoomLevel);case UpdateConfidenceThreshold() when updateConfidenceThreshold != null:
return updateConfidenceThreshold(_that.threshold);case UpdateIouThreshold() when updateIouThreshold != null:
return updateIouThreshold(_that.threshold);case UpdateNumItemsThreshold() when updateNumItemsThreshold != null:
return updateNumItemsThreshold(_that.threshold);case DetectionsOccurred() when detectionsOccurred != null:
return detectionsOccurred(_that.detections);case ToggleSlider() when toggleSlider != null:
return toggleSlider(_that.type);case UpdateFps() when updateFps != null:
return updateFps(_that.fps);case UpdateLensFacing() when updateLensFacing != null:
return updateLensFacing(_that.lensFacing);case RetryModelDownload() when retryModelDownload != null:
return retryModelDownload();case ResumeCamera() when resumeCamera != null:
return resumeCamera();case SetInitialConfig() when setInitialConfig != null:
return setInitialConfig();case StartSystemMonitor() when startSystemMonitor != null:
return startSystemMonitor();case _:
  return null;

}
}

}

/// @nodoc


class InitializeCamera implements CameraInferenceEvent {
  const InitializeCamera();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializeCamera);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CameraInferenceEvent.initializeCamera()';
}


}




/// @nodoc


class ChangeModel implements CameraInferenceEvent {
  const ChangeModel(this.model);
  

 final  ModelType model;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ChangeModelCopyWith<ChangeModel> get copyWith => _$ChangeModelCopyWithImpl<ChangeModel>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ChangeModel&&(identical(other.model, model) || other.model == model));
}


@override
int get hashCode => Object.hash(runtimeType,model);

@override
String toString() {
  return 'CameraInferenceEvent.changeModel(model: $model)';
}


}

/// @nodoc
abstract mixin class $ChangeModelCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $ChangeModelCopyWith(ChangeModel value, $Res Function(ChangeModel) _then) = _$ChangeModelCopyWithImpl;
@useResult
$Res call({
 ModelType model
});




}
/// @nodoc
class _$ChangeModelCopyWithImpl<$Res>
    implements $ChangeModelCopyWith<$Res> {
  _$ChangeModelCopyWithImpl(this._self, this._then);

  final ChangeModel _self;
  final $Res Function(ChangeModel) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? model = null,}) {
  return _then(ChangeModel(
null == model ? _self.model : model // ignore: cast_nullable_to_non_nullable
as ModelType,
  ));
}


}

/// @nodoc


class FlipCamera implements CameraInferenceEvent {
  const FlipCamera();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FlipCamera);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CameraInferenceEvent.flipCamera()';
}


}




/// @nodoc


class SetZoomLevel implements CameraInferenceEvent {
  const SetZoomLevel(this.zoomLevel);
  

 final  double zoomLevel;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SetZoomLevelCopyWith<SetZoomLevel> get copyWith => _$SetZoomLevelCopyWithImpl<SetZoomLevel>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SetZoomLevel&&(identical(other.zoomLevel, zoomLevel) || other.zoomLevel == zoomLevel));
}


@override
int get hashCode => Object.hash(runtimeType,zoomLevel);

@override
String toString() {
  return 'CameraInferenceEvent.setZoomLevel(zoomLevel: $zoomLevel)';
}


}

/// @nodoc
abstract mixin class $SetZoomLevelCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $SetZoomLevelCopyWith(SetZoomLevel value, $Res Function(SetZoomLevel) _then) = _$SetZoomLevelCopyWithImpl;
@useResult
$Res call({
 double zoomLevel
});




}
/// @nodoc
class _$SetZoomLevelCopyWithImpl<$Res>
    implements $SetZoomLevelCopyWith<$Res> {
  _$SetZoomLevelCopyWithImpl(this._self, this._then);

  final SetZoomLevel _self;
  final $Res Function(SetZoomLevel) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? zoomLevel = null,}) {
  return _then(SetZoomLevel(
null == zoomLevel ? _self.zoomLevel : zoomLevel // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}

/// @nodoc


class UpdateConfidenceThreshold implements CameraInferenceEvent {
  const UpdateConfidenceThreshold(this.threshold);
  

 final  double threshold;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateConfidenceThresholdCopyWith<UpdateConfidenceThreshold> get copyWith => _$UpdateConfidenceThresholdCopyWithImpl<UpdateConfidenceThreshold>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateConfidenceThreshold&&(identical(other.threshold, threshold) || other.threshold == threshold));
}


@override
int get hashCode => Object.hash(runtimeType,threshold);

@override
String toString() {
  return 'CameraInferenceEvent.updateConfidenceThreshold(threshold: $threshold)';
}


}

/// @nodoc
abstract mixin class $UpdateConfidenceThresholdCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $UpdateConfidenceThresholdCopyWith(UpdateConfidenceThreshold value, $Res Function(UpdateConfidenceThreshold) _then) = _$UpdateConfidenceThresholdCopyWithImpl;
@useResult
$Res call({
 double threshold
});




}
/// @nodoc
class _$UpdateConfidenceThresholdCopyWithImpl<$Res>
    implements $UpdateConfidenceThresholdCopyWith<$Res> {
  _$UpdateConfidenceThresholdCopyWithImpl(this._self, this._then);

  final UpdateConfidenceThreshold _self;
  final $Res Function(UpdateConfidenceThreshold) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? threshold = null,}) {
  return _then(UpdateConfidenceThreshold(
null == threshold ? _self.threshold : threshold // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}

/// @nodoc


class UpdateIouThreshold implements CameraInferenceEvent {
  const UpdateIouThreshold(this.threshold);
  

 final  double threshold;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateIouThresholdCopyWith<UpdateIouThreshold> get copyWith => _$UpdateIouThresholdCopyWithImpl<UpdateIouThreshold>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateIouThreshold&&(identical(other.threshold, threshold) || other.threshold == threshold));
}


@override
int get hashCode => Object.hash(runtimeType,threshold);

@override
String toString() {
  return 'CameraInferenceEvent.updateIouThreshold(threshold: $threshold)';
}


}

/// @nodoc
abstract mixin class $UpdateIouThresholdCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $UpdateIouThresholdCopyWith(UpdateIouThreshold value, $Res Function(UpdateIouThreshold) _then) = _$UpdateIouThresholdCopyWithImpl;
@useResult
$Res call({
 double threshold
});




}
/// @nodoc
class _$UpdateIouThresholdCopyWithImpl<$Res>
    implements $UpdateIouThresholdCopyWith<$Res> {
  _$UpdateIouThresholdCopyWithImpl(this._self, this._then);

  final UpdateIouThreshold _self;
  final $Res Function(UpdateIouThreshold) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? threshold = null,}) {
  return _then(UpdateIouThreshold(
null == threshold ? _self.threshold : threshold // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}

/// @nodoc


class UpdateNumItemsThreshold implements CameraInferenceEvent {
  const UpdateNumItemsThreshold(this.threshold);
  

 final  int threshold;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateNumItemsThresholdCopyWith<UpdateNumItemsThreshold> get copyWith => _$UpdateNumItemsThresholdCopyWithImpl<UpdateNumItemsThreshold>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateNumItemsThreshold&&(identical(other.threshold, threshold) || other.threshold == threshold));
}


@override
int get hashCode => Object.hash(runtimeType,threshold);

@override
String toString() {
  return 'CameraInferenceEvent.updateNumItemsThreshold(threshold: $threshold)';
}


}

/// @nodoc
abstract mixin class $UpdateNumItemsThresholdCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $UpdateNumItemsThresholdCopyWith(UpdateNumItemsThreshold value, $Res Function(UpdateNumItemsThreshold) _then) = _$UpdateNumItemsThresholdCopyWithImpl;
@useResult
$Res call({
 int threshold
});




}
/// @nodoc
class _$UpdateNumItemsThresholdCopyWithImpl<$Res>
    implements $UpdateNumItemsThresholdCopyWith<$Res> {
  _$UpdateNumItemsThresholdCopyWithImpl(this._self, this._then);

  final UpdateNumItemsThreshold _self;
  final $Res Function(UpdateNumItemsThreshold) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? threshold = null,}) {
  return _then(UpdateNumItemsThreshold(
null == threshold ? _self.threshold : threshold // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class DetectionsOccurred implements CameraInferenceEvent {
  const DetectionsOccurred(final  List<DetectionResult> detections): _detections = detections;
  

 final  List<DetectionResult> _detections;
 List<DetectionResult> get detections {
  if (_detections is EqualUnmodifiableListView) return _detections;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_detections);
}


/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DetectionsOccurredCopyWith<DetectionsOccurred> get copyWith => _$DetectionsOccurredCopyWithImpl<DetectionsOccurred>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DetectionsOccurred&&const DeepCollectionEquality().equals(other._detections, _detections));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_detections));

@override
String toString() {
  return 'CameraInferenceEvent.detectionsOccurred(detections: $detections)';
}


}

/// @nodoc
abstract mixin class $DetectionsOccurredCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $DetectionsOccurredCopyWith(DetectionsOccurred value, $Res Function(DetectionsOccurred) _then) = _$DetectionsOccurredCopyWithImpl;
@useResult
$Res call({
 List<DetectionResult> detections
});




}
/// @nodoc
class _$DetectionsOccurredCopyWithImpl<$Res>
    implements $DetectionsOccurredCopyWith<$Res> {
  _$DetectionsOccurredCopyWithImpl(this._self, this._then);

  final DetectionsOccurred _self;
  final $Res Function(DetectionsOccurred) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? detections = null,}) {
  return _then(DetectionsOccurred(
null == detections ? _self._detections : detections // ignore: cast_nullable_to_non_nullable
as List<DetectionResult>,
  ));
}


}

/// @nodoc


class ToggleSlider implements CameraInferenceEvent {
  const ToggleSlider(this.type);
  

 final  SliderType type;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ToggleSliderCopyWith<ToggleSlider> get copyWith => _$ToggleSliderCopyWithImpl<ToggleSlider>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ToggleSlider&&(identical(other.type, type) || other.type == type));
}


@override
int get hashCode => Object.hash(runtimeType,type);

@override
String toString() {
  return 'CameraInferenceEvent.toggleSlider(type: $type)';
}


}

/// @nodoc
abstract mixin class $ToggleSliderCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $ToggleSliderCopyWith(ToggleSlider value, $Res Function(ToggleSlider) _then) = _$ToggleSliderCopyWithImpl;
@useResult
$Res call({
 SliderType type
});




}
/// @nodoc
class _$ToggleSliderCopyWithImpl<$Res>
    implements $ToggleSliderCopyWith<$Res> {
  _$ToggleSliderCopyWithImpl(this._self, this._then);

  final ToggleSlider _self;
  final $Res Function(ToggleSlider) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? type = null,}) {
  return _then(ToggleSlider(
null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as SliderType,
  ));
}


}

/// @nodoc


class UpdateFps implements CameraInferenceEvent {
  const UpdateFps(this.fps);
  

 final  double fps;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateFpsCopyWith<UpdateFps> get copyWith => _$UpdateFpsCopyWithImpl<UpdateFps>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateFps&&(identical(other.fps, fps) || other.fps == fps));
}


@override
int get hashCode => Object.hash(runtimeType,fps);

@override
String toString() {
  return 'CameraInferenceEvent.updateFps(fps: $fps)';
}


}

/// @nodoc
abstract mixin class $UpdateFpsCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $UpdateFpsCopyWith(UpdateFps value, $Res Function(UpdateFps) _then) = _$UpdateFpsCopyWithImpl;
@useResult
$Res call({
 double fps
});




}
/// @nodoc
class _$UpdateFpsCopyWithImpl<$Res>
    implements $UpdateFpsCopyWith<$Res> {
  _$UpdateFpsCopyWithImpl(this._self, this._then);

  final UpdateFps _self;
  final $Res Function(UpdateFps) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? fps = null,}) {
  return _then(UpdateFps(
null == fps ? _self.fps : fps // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}

/// @nodoc


class UpdateLensFacing implements CameraInferenceEvent {
  const UpdateLensFacing(this.lensFacing);
  

 final  LensFacing lensFacing;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateLensFacingCopyWith<UpdateLensFacing> get copyWith => _$UpdateLensFacingCopyWithImpl<UpdateLensFacing>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateLensFacing&&(identical(other.lensFacing, lensFacing) || other.lensFacing == lensFacing));
}


@override
int get hashCode => Object.hash(runtimeType,lensFacing);

@override
String toString() {
  return 'CameraInferenceEvent.updateLensFacing(lensFacing: $lensFacing)';
}


}

/// @nodoc
abstract mixin class $UpdateLensFacingCopyWith<$Res> implements $CameraInferenceEventCopyWith<$Res> {
  factory $UpdateLensFacingCopyWith(UpdateLensFacing value, $Res Function(UpdateLensFacing) _then) = _$UpdateLensFacingCopyWithImpl;
@useResult
$Res call({
 LensFacing lensFacing
});




}
/// @nodoc
class _$UpdateLensFacingCopyWithImpl<$Res>
    implements $UpdateLensFacingCopyWith<$Res> {
  _$UpdateLensFacingCopyWithImpl(this._self, this._then);

  final UpdateLensFacing _self;
  final $Res Function(UpdateLensFacing) _then;

/// Create a copy of CameraInferenceEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? lensFacing = null,}) {
  return _then(UpdateLensFacing(
null == lensFacing ? _self.lensFacing : lensFacing // ignore: cast_nullable_to_non_nullable
as LensFacing,
  ));
}


}

/// @nodoc


class RetryModelDownload implements CameraInferenceEvent {
  const RetryModelDownload();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RetryModelDownload);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CameraInferenceEvent.retryModelDownload()';
}


}




/// @nodoc


class ResumeCamera implements CameraInferenceEvent {
  const ResumeCamera();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ResumeCamera);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CameraInferenceEvent.resumeCamera()';
}


}




/// @nodoc


class SetInitialConfig implements CameraInferenceEvent {
  const SetInitialConfig();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SetInitialConfig);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CameraInferenceEvent.setInitialConfig()';
}


}




/// @nodoc


class StartSystemMonitor implements CameraInferenceEvent {
  const StartSystemMonitor();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StartSystemMonitor);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'CameraInferenceEvent.startSystemMonitor()';
}


}




// dart format on
